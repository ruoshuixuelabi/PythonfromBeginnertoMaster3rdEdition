from threading import Thread, Lock
import time

"""
14.6.1 什么是互斥锁

由于线程可以对全局变量进行随意修改,这就可能造成多线程之间对全局变量的混乱。
依然以一套房子为例,当此套房子内只有一位居住者(单线程)时,他可以在任意时刻使用其中的任何一个房间,如厨房、卧室和卫生间等。
但是,当这套房子有多位居住者(多线程)时,他就不能在任意时刻使用某些房间,如卫生间,否则就会造成混乱。

如何解决这个问题呢？一种防止他人进入房间的简单方法就是在门上加一把锁。
先到的人锁上门,后到的人就在门口排队,等待锁被打开时再进去,如图14.18所示。

这就是互斥锁(mutual exclusion,缩写为Mutex),防止多个线程同时读写某一块内存区域。
互斥锁为资源引入一个状态,即锁定或非锁定。某个线程要更改共享数据时,先将其锁定。
此时,资源的状态为锁定,其他线程不能更改,直到该线程释放资源,将资源的状态变成非锁定时,其他线程才能再次锁定该资源。
互斥锁保证了每次只有一个线程进行写入操作,从而保证了多线程情况下数据的正确性。

14.6.2 使用互斥锁

在threading模块中使用 Lock 类可以方便地处理锁定。Lock 类有两个方法,即 acquire()锁定和 release()释放锁。示例用法如下：

mutex = threading.Lock()  # 创建锁
mutex.acquire([blocking])  # 锁定
mutex.release()  # 释放锁

- acquire([blocking])：获取锁定,如果有必要,则需要阻塞到锁定被释放为止。
假设提供blocking参数并将它设置为False：当无法获取锁定时,将立即返回False；当成功获取锁定时,将返回True。
- release()：释放一个锁定。当锁定处于未锁定状态时,或者从与原本调用acquire()方法的不同线程中调用此方法,将会出现错误。

下面通过一个例子学习如何使用互斥锁。

【例14.6】 使用互斥锁实现多人同时订购电影票的功能。 
电影院某个场次只有100张电影票,10个用户同时抢购该电影票。每售出一张,显示一次剩余电影票张数。
使用多线程和互斥锁模拟该过程,代码如下：
"""
n = 100  # 共100张票


def task():
    global n
    mutex.acquire()  # 上锁
    temp = n  # 赋值给临时变量
    time.sleep(0.1)  # 休眠0.1秒
    n = temp - 1  # 数量减1
    print('购买成功,剩余%d张电影票' % n)
    mutex.release()  # 释放锁


if __name__ == '__main__':
    mutex = Lock()  # 实例化Lock类
    t_l = []  # 初始化一个列表
    for i in range(10):
        t = Thread(target=task)  # 实例化线程类
        t_l.append(t)  # 将线程实例存入列表中
        t.start()  # 创建线程
    for t in t_l:
        t.join()  # 等待子线程结束

"""
在上述代码中创建了10个线程,全部执行task()函数。为解决资源竞争问题,使用 mutex.acquire()函数实现资源锁定,
第一个获取资源的线程锁定后,其他线程等待 mutex.release()解锁。因此,每次只有一个线程执行task()函数。运行结果如图14.19所示。

使用互斥锁时,要避免死锁。在多任务系统下,当一个或多个线程等待系统资源,
而资源又被线程本身或其他线程占用时,就形成了死锁,如图14.20所示。
"""